{"ast":null,"code":"import * as THREE from \"three\";\nexport default (canvas => {\n  // these need to be accessed inside more than one function so we'll declare them first\n  let container;\n  let camera;\n  let renderer;\n  let scene;\n  let mesh;\n\n  function init() {\n    // Get a reference to the container element that will hold our scene\n    container = document.querySelector(\"#scene-container\"); // create a Scene\n\n    scene = new THREE.Scene();\n    scene.background = new THREE.Color(0x8fbcd4); // set up the options for a perspective camera\n\n    const fov = 35; // fov = Field Of View\n\n    const aspect = container.clientWidth / container.clientHeight;\n    const near = 0.1;\n    const far = 100;\n    camera = new THREE.PerspectiveCamera(fov, aspect, near, far); // every object is initially created at ( 0, 0, 0 )\n    // we'll move the camera back a bit so that we can view the scene\n\n    camera.position.set(0, 0, 10); // create a geometry\n\n    const geometry = new THREE.BoxBufferGeometry(2, 2, 2); // create a purple Standard material\n\n    const material = new THREE.MeshStandardMaterial({\n      color: 0x800080\n    }); // create a Mesh containing the geometry and material\n\n    mesh = new THREE.Mesh(geometry, material); // add the mesh to the scene object\n\n    scene.add(mesh); // Create a directional light\n\n    const light = new THREE.DirectionalLight(0xffffff, 5.0); // move the light back and up a bit\n\n    light.position.set(10, 10, 10); // remember to add the light to the scene\n\n    scene.add(light); // create a WebGLRenderer and set its width and height\n\n    renderer = new THREE.WebGLRenderer({\n      antialias: true\n    });\n    renderer.setSize(container.clientWidth, container.clientHeight);\n    renderer.setPixelRatio(window.devicePixelRatio); // add the automatically created <canvas> element to the page\n\n    container.appendChild(renderer.domElement);\n  }\n\n  function animate() {\n    // call animate recursively\n    requestAnimationFrame(animate); // increase the mesh's rotation each frame\n\n    mesh.rotation.z += 0.01;\n    mesh.rotation.x += 0.01;\n    mesh.rotation.y += 0.01; // render, or 'create a still image', of the scene\n    // this will create one still image / frame each time the animate\n    // function calls itself\n\n    renderer.render(scene, camera);\n  } // call the init function to set everything up\n\n\n  init(); // then call the animate function to render the scene\n\n  animate();\n});","map":{"version":3,"sources":["/Users/pflaxalt/Repositories/_pfl/web/sketches/three/t1.js"],"names":["THREE","canvas","container","camera","renderer","scene","mesh","init","document","querySelector","Scene","background","Color","fov","aspect","clientWidth","clientHeight","near","far","PerspectiveCamera","position","set","geometry","BoxBufferGeometry","material","MeshStandardMaterial","color","Mesh","add","light","DirectionalLight","WebGLRenderer","antialias","setSize","setPixelRatio","window","devicePixelRatio","appendChild","domElement","animate","requestAnimationFrame","rotation","z","x","y","render"],"mappings":"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","sourcesContent":["import * as THREE from \"three\";\n\nexport default canvas => {\n  // these need to be accessed inside more than one function so we'll declare them first\n  let container;\n  let camera;\n  let renderer;\n  let scene;\n  let mesh;\n\n  function init() {\n    // Get a reference to the container element that will hold our scene\n    container = document.querySelector(\"#scene-container\");\n\n    // create a Scene\n    scene = new THREE.Scene();\n\n    scene.background = new THREE.Color(0x8fbcd4);\n\n    // set up the options for a perspective camera\n    const fov = 35; // fov = Field Of View\n    const aspect = container.clientWidth / container.clientHeight;\n    const near = 0.1;\n    const far = 100;\n\n    camera = new THREE.PerspectiveCamera(fov, aspect, near, far);\n\n    // every object is initially created at ( 0, 0, 0 )\n    // we'll move the camera back a bit so that we can view the scene\n    camera.position.set(0, 0, 10);\n\n    // create a geometry\n    const geometry = new THREE.BoxBufferGeometry(2, 2, 2);\n\n    // create a purple Standard material\n    const material = new THREE.MeshStandardMaterial({ color: 0x800080 });\n\n    // create a Mesh containing the geometry and material\n    mesh = new THREE.Mesh(geometry, material);\n\n    // add the mesh to the scene object\n    scene.add(mesh);\n\n    // Create a directional light\n    const light = new THREE.DirectionalLight(0xffffff, 5.0);\n\n    // move the light back and up a bit\n    light.position.set(10, 10, 10);\n\n    // remember to add the light to the scene\n    scene.add(light);\n\n    // create a WebGLRenderer and set its width and height\n    renderer = new THREE.WebGLRenderer({ antialias: true });\n    renderer.setSize(container.clientWidth, container.clientHeight);\n\n    renderer.setPixelRatio(window.devicePixelRatio);\n\n    // add the automatically created <canvas> element to the page\n    container.appendChild(renderer.domElement);\n  }\n\n  function animate() {\n    // call animate recursively\n    requestAnimationFrame(animate);\n\n    // increase the mesh's rotation each frame\n    mesh.rotation.z += 0.01;\n    mesh.rotation.x += 0.01;\n    mesh.rotation.y += 0.01;\n\n    // render, or 'create a still image', of the scene\n    // this will create one still image / frame each time the animate\n    // function calls itself\n    renderer.render(scene, camera);\n  }\n\n  // call the init function to set everything up\n  init();\n\n  // then call the animate function to render the scene\n  animate();\n};\n"]},"metadata":{},"sourceType":"module"}