{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/**\n *\n * Shader fun\n * @author Peter Laxalt\n *\n */\n// Begin Component\n// __________________________________________________________________________\nconst DharmaCanvasDisplay = (W, H, ID, // DharmaTheme,\nparentEl) => p => {\n  // _________________________________________________\n  // Config\n  let canvas; // ____________________________\n  // Fonts\n\n  let dharmaFont; // ____________________________\n  // Typography\n\n  let text = \"LAXALT\";\n  let splitCharacterArray = text.split(\"\");\n  let characters = splitCharacterArray.map((character, idx) => {\n    return {\n      letter: character,\n      count: 1,\n      idx: idx,\n      copies: 5,\n      copiesLastVisible: 0,\n      copiesAreVisible: false,\n      countIsIncrementing: true,\n      countIsDecrementing: false,\n      copiesAreIncrementing: true,\n      copiesAreDecrementing: false\n    };\n  });\n  let characterCount = splitCharacterArray.length;\n  let characterWidth = W / characterCount;\n  let characterSize = H * 1.15;\n  let verticalSkewDivisible = 2.75;\n  let characterSkewDivisible = 1.36;\n  console.log(characterSize, \"characterSize\"); // ____________________________\n  // Counts\n  // let renderCount: number = 0;\n\n  let previousCountUpdateTime = 0;\n  let previousCopyUpdateTime = 0; // ____________________________\n  // Strokes\n\n  let strokeWidth = 4;\n  let strokeOffset = strokeWidth * 1.5; // ____________________________\n  // Limits\n\n  let maxCount = 3;\n  let minCount = 1;\n  let maxCopies = 12;\n  let minCopies = 1;\n  let frameRate = 60; // ____________________________\n  // Translation\n  // let previousVerticalTranslation: number = H / 2.25;\n\n  let verticalTranslationWhitespaceCompensation = 2.25;\n\n  const previousHorizontalTranslation = idx => -60 + (characterWidth * idx + characterWidth / 1.5 + strokeOffset); // _________________________________________________\n  // Preload\n\n\n  p.preload = () => {\n    dharmaFont = p.loadFont(`/fonts/dharma/dharma_regular.ttf`);\n  }; // _________________________________________________\n  // Setup\n\n\n  p.setup = () => {\n    // Our Canvas\n    canvas = p.createCanvas(W, H); // ThreeWaterCanvas(parentEl, canvas.elt);\n\n    p.frameRate(frameRate);\n\n    if (window.devicePixelRatio > 1 && window.devicePixelRatio < 3) {\n      p.pixelDensity(1.25);\n    }\n  }; // _________________________________________________\n  // Update Character\n\n\n  const updateCharacter = (char, idx) => {\n    if (char.count < maxCount && char.countIsIncrementing) {\n      characters[idx] = _objectSpread(_objectSpread({}, char), {}, {\n        count: char.count + 1\n      });\n      previousCountUpdateTime = p.millis();\n      return;\n    } else if (char.count === maxCount) {\n      characters[idx] = _objectSpread(_objectSpread({}, char), {}, {\n        count: char.count - 1,\n        countIsIncrementing: false,\n        countIsDecrementing: true\n      });\n      previousCountUpdateTime = p.millis();\n      return;\n    } else if (char.count > minCount && char.countIsDecrementing) {\n      characters[idx] = _objectSpread(_objectSpread({}, char), {}, {\n        count: char.count - 1,\n        countIsDecrementing: true\n      });\n      previousCountUpdateTime = p.millis();\n      return;\n    } else if (char.count === minCount && char.countIsDecrementing) {\n      characters[idx] = _objectSpread(_objectSpread({}, char), {}, {\n        count: char.count + 1,\n        countIsIncrementing: true,\n        countIsDecrementing: false\n      });\n      previousCountUpdateTime = p.millis();\n      return;\n    }\n\n    return;\n  }; // _________________________________________________\n  // Update Copies\n\n\n  const updateCopies = (char, idx) => {\n    if (char.copies < maxCopies && char.copiesAreIncrementing) {\n      characters[idx] = _objectSpread(_objectSpread({}, char), {}, {\n        copies: char.copies + 1\n      });\n      previousCopyUpdateTime = p.millis();\n      return;\n    } else if (char.copies === maxCopies) {\n      characters[idx] = _objectSpread(_objectSpread({}, char), {}, {\n        copies: char.copies - 1,\n        copiesAreIncrementing: false,\n        copiesAreDecrementing: true\n      });\n      previousCopyUpdateTime = p.millis();\n      return;\n    } else if (char.copies > minCopies && char.copiesAreDecrementing) {\n      characters[idx] = _objectSpread(_objectSpread({}, char), {}, {\n        copies: char.copies - 1,\n        copiesAreDecrementing: true\n      });\n      previousCopyUpdateTime = p.millis();\n      return;\n    } else if (char.copies === minCopies && char.copiesAreDecrementing) {\n      characters[idx] = _objectSpread(_objectSpread({}, char), {}, {\n        copies: char.copies + 1,\n        copiesAreIncrementing: true,\n        copiesAreDecrementing: false\n      });\n      previousCopyUpdateTime = p.millis();\n      return;\n    }\n\n    return;\n  }; // _________________________________________________\n  // Draw\n\n\n  p.draw = () => {\n    if (p.frameCount % 10 === 0) {\n      p.background(window.laxaltUniversalTheme.background);\n      p.textFont(dharmaFont);\n      p.textSize(characterSize);\n      p.textAlign(p.CENTER, p.CENTER);\n      p.fill(`${window.laxaltUniversalTheme.foreground}`);\n      p.strokeWeight(strokeWidth);\n      p.stroke(window.laxaltUniversalTheme.background);\n\n      if (H && W) {\n        // _________________________________________\n        // Loop through our copies\n        characters.map((char, idx) => {\n          p.scale(1, 1);\n          let randomCharPick = Math.random() <= 0.5;\n\n          if (randomCharPick) {\n            updateCopies(char, idx);\n          }\n\n          if (randomCharPick && p.millis() - previousCountUpdateTime > 3000) {\n            updateCharacter(char, idx);\n          }\n\n          let countArray = Array.from(Array(char.count).keys());\n          countArray = countArray.map(countNumber => {\n            return countNumber + 1;\n          }); // _________________________________________\n          // Duplicate positions\n\n          countArray.map((countNumber, idxx) => {\n            let verticalScale = 1 / (char.count * 0.95);\n            let duplicateVerticalPosition = char.count == 1 ? H / verticalTranslationWhitespaceCompensation : characterSize / verticalSkewDivisible + characterSize / characterSkewDivisible * idxx; // _________________________________________\n            // Make copies\n\n            let copiesArray = Array.from(Array(char.copies).keys()); // let randomCopyPick = Math.random() <= 0.5;\n\n            copiesArray = copiesArray.map(copyNumber => {\n              return copyNumber + 1;\n            }); // let randomCopyPick = Math.random() <= 0.5;\n            // let copyTimer = p.millis() - previousCopiesVisibleTime > 2000;\n\n            previousCopyUpdateTime; // let isFirstCount = true;\n\n            copiesArray.map((copyNumber, idxxx) => {\n              // let centerCoordsX = W / 2;\n              // let centerCoordsY = H / 2;\n              // let horizontalTranslate =\n              //   copyNumber !== 1\n              //     ? (previousHorizontalTranslation(idx) +\n              //         (strokeOffset / (p.mouseX / 100)) * copyNumber)\n              //     : previousHorizontalTranslation(idx) +\n              //       strokeOffset * copyNumber;\n              // let verticalTranslate =\n              //   copyNumber !== 1\n              //     ? (duplicateVerticalPosition - (strokeOffset / (p.mouseX / 100)) * copyNumber)\n              //     : duplicateVerticalPosition - strokeOffset * copyNumber;\n              let horizontalTranslate = previousHorizontalTranslation(idx) + strokeOffset * copyNumber;\n              let verticalTranslate = duplicateVerticalPosition - strokeOffset * copyNumber;\n              p.push();\n              p.scale(1, verticalScale);\n              p.text(char.letter, horizontalTranslate, verticalTranslate);\n              p.pop();\n            });\n          });\n        });\n      }\n    }\n  };\n\n  p.windowResized = () => {\n    p.resizeCanvas(W, H);\n  };\n};\n\nexport default DharmaCanvasDisplay;","map":null,"metadata":{},"sourceType":"module"}