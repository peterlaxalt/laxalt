{"ast":null,"code":"import _Object$defineProperty from \"@babel/runtime-corejs2/core-js/object/define-property\";\nimport _Object$defineProperties from \"@babel/runtime-corejs2/core-js/object/define-properties\";\nimport _Object$getOwnPropertyDescriptors from \"@babel/runtime-corejs2/core-js/object/get-own-property-descriptors\";\nimport _Object$getOwnPropertyDescriptor from \"@babel/runtime-corejs2/core-js/object/get-own-property-descriptor\";\nimport _Object$getOwnPropertySymbols from \"@babel/runtime-corejs2/core-js/object/get-own-property-symbols\";\nimport _Object$keys from \"@babel/runtime-corejs2/core-js/object/keys\";\nimport _Array$from from \"@babel/runtime-corejs2/core-js/array/from\";\nimport _defineProperty from \"@babel/runtime-corejs2/helpers/esm/defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = _Object$keys(object); if (_Object$getOwnPropertySymbols) { var symbols = _Object$getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return _Object$getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (_Object$getOwnPropertyDescriptors) { _Object$defineProperties(target, _Object$getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { _Object$defineProperty(target, key, _Object$getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\n/**\n *\n * Shader fun\n * @author Peter Laxalt\n *\n */\nimport { Theme } from \"../../constants/Theme\"; // Begin Component\n// __________________________________________________________________________\n\nvar DharmaCanvasDisplay = function DharmaCanvasDisplay(W, H, ID, BG) {\n  return function (p) {\n    // _________________________________________________\n    // Config\n    // ____________________________\n    // Fonts\n    var dharmaFont; // ____________________________\n    // Typography\n\n    var text = \"LAXALT\";\n    var splitCharacterArray = text.split(\"\");\n    var characters = splitCharacterArray.map(function (character, idx) {\n      return {\n        letter: character,\n        count: 1,\n        idx: idx,\n        copies: 5,\n        isIncrementing: true,\n        isDecrementing: false\n      };\n    });\n    var characterCount = splitCharacterArray.length;\n    var characterWidth = W / characterCount;\n    var characterSize = H * 1.25;\n    console.log(characterSize, \"characterSize\"); // ____________________________\n    // Counts\n    // let renderCount: number = 0;\n\n    var previousTime = 0; // ____________________________\n    // Strokes\n\n    var strokeWidth = 4;\n    var strokeOffset = strokeWidth * 1.5; // ____________________________\n    // Incrementing\n\n    var maxCount = 6;\n    var minCount = 1; // ____________________________\n    // Translation\n    // let previousVerticalTranslation: number = H / 2.25;\n\n    var verticalTranslationWhitespaceCompensation = 2.25;\n\n    var previousHorizontalTranslation = function previousHorizontalTranslation(idx) {\n      return -60 + (characterWidth * idx + characterWidth / 1.5 + strokeOffset);\n    }; // const previousHorizontalTranslation = (idx: number) =>\n    //   characterWidth * idx + characterWidth / 2 + strokeOffset * renderCount;\n    // let characterVerticalTranslation = 0.963; // Multiplied by the viewBoxHeight\n    // let characterVerticalTranslation: number = 0.993; // Multiplied by the viewBoxHeight\n    // let characterHorizontalScale: number = 0.75; // Multiplied by the characterWidth\n    // let characterVerticalScale: number = 1.38; // Multiplied by the characterWidth\n    // _________________________________________________\n    // Preload\n\n\n    p.preload = function () {\n      dharmaFont = p.loadFont(\"/fonts/dharma/dharma_regular.ttf\");\n    }; // _________________________________________________\n    // Setup\n\n\n    p.setup = function () {\n      // Our Canvas\n      p.createCanvas(W, H);\n    }; // _________________________________________________\n    // Update Character\n\n\n    var updateCharacter = function updateCharacter(_char, idx) {\n      if (_char.count < maxCount && _char.isIncrementing) {\n        characters[idx] = _objectSpread({}, _char, {\n          count: _char.count + 1\n        });\n        previousTime = p.millis();\n      } else if (_char.count === maxCount) {\n        characters[idx] = _objectSpread({}, _char, {\n          count: _char.count - 1,\n          isIncrementing: false,\n          isDecrementing: true\n        });\n        previousTime = p.millis();\n      } else if (_char.count > minCount && _char.isDecrementing) {\n        characters[idx] = _objectSpread({}, _char, {\n          count: _char.count - 1,\n          isDecrementing: true\n        });\n        previousTime = p.millis();\n      } else if (_char.count === minCount && _char.isDecrementing) {\n        characters[idx] = _objectSpread({}, _char, {\n          count: _char.count + 1,\n          isIncrementing: true,\n          isDecrementing: false\n        });\n        previousTime = p.millis();\n      }\n    }; // _________________________________________________\n    // Draw\n\n\n    p.draw = function () {\n      p.background(BG);\n      p.textFont(dharmaFont);\n      p.textSize(characterSize);\n      p.textAlign(p.CENTER, p.CENTER);\n      p.fill(\"\".concat(Theme.Color.Galaxy));\n      p.strokeWeight(strokeWidth);\n      p.stroke(BG);\n\n      if (H && W) {\n        // _________________________________________\n        // Loop through our copies\n        characters.map(function (_char2, idx) {\n          p.scale(1, 1);\n          var randomCharPick = Math.random() <= 0.5;\n\n          if (randomCharPick && p.millis() - previousTime > 3000) {\n            updateCharacter(_char2, idx);\n          }\n\n          var countArray = _Array$from(Array(_char2.count).keys());\n\n          countArray = countArray.map(function (countNumber) {\n            return countNumber + 1;\n          }); // _________________________________________\n          // Duplicate positions\n\n          countArray.map(function (countNumber, idxx) {\n            var verticalScale = 1 / (_char2.count * 0.95);\n            var verticalSkewDivisible = 2.75;\n            var characterSkewDivisible = 1.36;\n            var duplicateVerticalPosition = _char2.count == 1 ? H / verticalTranslationWhitespaceCompensation : characterSize / verticalSkewDivisible + characterSize / characterSkewDivisible * idxx; // _________________________________________\n            // Make copies\n\n            var copiesArray = _Array$from(Array(_char2.copies).keys()); // let randomCopyPick = Math.random() <= 0.5;\n\n\n            copiesArray = copiesArray.map(function (copyNumber) {\n              return copyNumber + 1;\n            });\n            copiesArray.map(function (copyNumber, idxxx) {\n              p.push();\n              p.scale(1, verticalScale);\n              p.text(_char2.letter, previousHorizontalTranslation(idx) + strokeOffset * copyNumber, duplicateVerticalPosition - strokeOffset * copyNumber);\n              p.pop();\n            });\n          });\n        });\n      }\n    };\n\n    p.windowResized = function () {\n      p.resizeCanvas(W, H);\n    };\n  };\n};\n\nexport default DharmaCanvasDisplay;","map":null,"metadata":{},"sourceType":"module"}