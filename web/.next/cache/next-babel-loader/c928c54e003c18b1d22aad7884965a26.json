{"ast":null,"code":"import _classCallCheck from \"/Users/pflaxalt/Repositories/_pfl/web/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/pflaxalt/Repositories/_pfl/web/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _defineProperty from \"/Users/pflaxalt/Repositories/_pfl/web/node_modules/@babel/runtime/helpers/esm/defineProperty\";\n\n/**\n *\n * * @see https://tympanus.net/codrops/2019/10/08/creating-a-water-like-distortion-effect-with-three-js/\n *\n */\n// ____________________________________________________________________________________\nimport * as THREE from \"three\";\n\n/**\n *\n * @name Easings\n * @see https://tympanus.net/codrops/2019/10/08/creating-a-water-like-distortion-effect-with-three-js/\n *\n */\nvar easeOutSine = function easeOutSine(t, b, c, d) {\n  return c * Math.sin(t / d * (Math.PI / 2)) + b;\n};\n\nvar easeOutQuad = function easeOutQuad(t, b, c, d) {\n  t /= d;\n  return -c * t * (t - 2) + b;\n};\n/**\n *\n * @name TouchTexture\n * @see https://tympanus.net/codrops/2019/10/08/creating-a-water-like-distortion-effect-with-three-js/\n *\n */\n\n\nexport var TouchTexture = /*#__PURE__*/function () {\n  // _________________________________\n  // Types\n  // _________________________________\n  // Constructor\n  function TouchTexture(options) {\n    _classCallCheck(this, TouchTexture);\n\n    _defineProperty(this, \"size\", void 0);\n\n    _defineProperty(this, \"radius\", void 0);\n\n    _defineProperty(this, \"width\", void 0);\n\n    _defineProperty(this, \"height\", void 0);\n\n    _defineProperty(this, \"canvas\", void 0);\n\n    _defineProperty(this, \"ctx\", void 0);\n\n    _defineProperty(this, \"debug\", void 0);\n\n    _defineProperty(this, \"points\", void 0);\n\n    _defineProperty(this, \"maxAge\", void 0);\n\n    _defineProperty(this, \"last\", void 0);\n\n    _defineProperty(this, \"texture\", void 0);\n\n    this.size = 64;\n    this.radius = this.size * 0.1;\n    this.width = this.height = this.size;\n    this.size = 64;\n    this.radius = this.size * 0.1;\n    this.points = [];\n    this.maxAge = 64;\n    this.last = null;\n\n    if (options.debug) {\n      this.width = window.innerWidth;\n      this.height = window.innerHeight;\n      this.radius = this.width * 0.05;\n    }\n\n    this.initTexture();\n    if (options.debug) document.body.append(this.canvas);\n  }\n  /**\n   *\n   * @description Initialize our canvas\n   *\n   */\n\n\n  _createClass(TouchTexture, [{\n    key: \"initTexture\",\n    value: function initTexture() {\n      this.canvas = document.createElement(\"canvas\");\n      this.canvas.id = \"TouchTexture\";\n      this.canvas.width = this.width;\n      this.canvas.height = this.height;\n      this.ctx = this.canvas.getContext(\"2d\");\n      this.clear();\n      this.texture = new THREE.Texture(this.canvas);\n    }\n    /**\n     *\n     * @description Note that addPoint() receives normalized values, from 0 to 1.\n     * If the canvas happens to resize, we can use the normalized points to draw using the correct size.\n     *\n     */\n\n  }, {\n    key: \"addPoint\",\n    value: function addPoint(point) {\n      var force = 0;\n      var vx = 0;\n      var vy = 0;\n      var last = this.last;\n\n      if (last) {\n        var relativeX = point.x - last.x;\n        var relativeY = point.y - last.y; // Distance formula\n\n        var distanceSquared = relativeX * relativeX + relativeY * relativeY;\n        var distance = Math.sqrt(distanceSquared); // Calculate Unit Vector\n\n        vx = relativeX / distance;\n        vy = relativeY / distance;\n        force = Math.min(distanceSquared * 10000, 1);\n      }\n\n      this.last = {\n        x: point.x,\n        y: point.y\n      };\n      this.points.push({\n        x: point.x,\n        y: point.y,\n        age: 0,\n        force: force,\n        vx: vx,\n        vy: vy\n      });\n    }\n    /**\n     *\n     * @description Letâ€™s create drawPoint(point) to start drawing the ripples:\n     * Convert the normalized point coordinates into canvas coordinates. Then, draw a happy little circle.\n     *\n     */\n\n  }, {\n    key: \"drawPoint\",\n    value: function drawPoint(point) {\n      // Convert normalized position into canvas coordinates\n      var pos = {\n        x: point.x * this.width,\n        y: point.y * this.height\n      };\n      var radius = this.radius;\n      this.ctx.beginPath();\n      this.ctx.arc(pos.x, pos.y, radius, 0, Math.PI * 2);\n      this.ctx.fill();\n      var ctx = this.ctx; // Lower the opacity as it gets older\n\n      var intensity = 1;\n\n      if (point.age < this.maxAge * 0.3) {\n        intensity = easeOutSine(point.age / (this.maxAge * 0.3), 0, 1, 1);\n      } else {\n        intensity = easeOutQuad(1 - (point.age - this.maxAge * 0.3) / (this.maxAge * 0.7), 0, 1, 1);\n      }\n\n      intensity *= point.force; // Insert data to color channels\n      // RG = Unit vector\n\n      var red = (point.vx + 1) / 2 * 255;\n      var green = (point.vy + 1) / 2 * 255; // B = Unit vector\n\n      var blue = intensity * 255;\n      var color = \"\".concat(red, \", \").concat(green, \", \").concat(blue);\n      var offset = this.size * 5;\n      this.ctx.beginPath();\n      this.ctx.fillStyle = \"rgba(255,0,0,1)\";\n      this.ctx.arc(pos.x - offset, pos.y - offset, radius, 0, Math.PI * 2);\n      this.ctx.fill();\n      this.ctx.shadowOffsetX = offset;\n      this.ctx.shadowOffsetY = offset;\n      this.ctx.shadowBlur = radius * 2;\n      this.ctx.shadowColor = \"rgba(\".concat(color, \",\").concat(0.2 * intensity, \")\");\n    }\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      this.ctx.fillStyle = \"black\";\n      this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);\n    }\n  }, {\n    key: \"update\",\n    value: function update() {\n      var _this = this;\n\n      this.clear();\n      var agePart = 1 / this.maxAge;\n      this.points.forEach(function (point, i) {\n        var slowAsOlder = 1 - point.age / _this.maxAge;\n        var force = point.force * agePart * slowAsOlder;\n        point.x += point.vx * force;\n        point.y += point.vy * force;\n        point.age += 1;\n\n        if (point.age > _this.maxAge) {\n          _this.points.splice(i, 1);\n        }\n      });\n      this.points.forEach(function (point) {\n        _this.drawPoint(point);\n      });\n      this.texture.needsUpdate = true;\n    }\n  }]);\n\n  return TouchTexture;\n}();","map":null,"metadata":{},"sourceType":"module"}