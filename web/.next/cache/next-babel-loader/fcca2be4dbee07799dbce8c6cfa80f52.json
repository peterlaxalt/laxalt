{"ast":null,"code":"import * as THREE from \"three\";\n// import { GUI } from \"./jsm/libs/dat.gui.module.js\";\nimport { OrbitControls } from \"./jsm/controls/OrbitControls.js\"; // Begin Component\n// __________________________________________________________________________\n\nexport var ThreeCanvas = function ThreeCanvas(container, CanvasTheme) {\n  /**\n   * Setup\n   */\n  var mesh, renderer, scene, camera, controls, sketch; // var gui;\n\n  var API = {\n    offsetX: 0,\n    offsetY: 0,\n    repeatX: 0.25,\n    repeatY: 0.25,\n    rotation: Math.PI / 4,\n    // positive is counter-clockwise\n    centerX: 0.5,\n    centerY: 0.5\n  };\n  init();\n\n  function init() {\n    renderer = new THREE.WebGLRenderer({\n      alpha: true\n    });\n    sketch = container;\n    renderer.setPixelRatio(window.devicePixelRatio);\n    renderer.setSize(window.innerWidth, window.innerHeight);\n    sketch.appendChild(renderer.domElement);\n    scene = new THREE.Scene();\n    camera = new THREE.PerspectiveCamera(40, window.innerWidth / window.innerHeight, 1, 1000);\n    camera.position.set(0, 0, 25); // scene.background = new THREE.Color(\n    //   `${hexToRGB(CanvasTheme.background, 0)}`\n    // );\n\n    scene.add(camera);\n    /**\n     * Camera controls\n     */\n\n    controls = new OrbitControls(camera, renderer.domElement);\n    controls.movementSpeed = 10000;\n    controls.domElement = renderer.domElement;\n    controls.rollSpeed = Math.PI / 24;\n    controls.autoForward = true;\n    controls.dragToLook = true;\n    controls.enableZoom = false;\n    var geometry = new THREE.TorusKnotBufferGeometry(10, 3, 200, 200);\n    new THREE.TextureLoader().load(\"/projects/three/stripe-tile.png\", function (texture) {\n      texture.wrapS = texture.wrapT = THREE.RepeatWrapping; // texture.anisotropy = renderer.capabilities.getMaxAnisotropy();\n\n      texture.anisotropy = 1; //texture.matrixAutoUpdate = false; // default true; set to false to update texture.matrix manually\n\n      var material = new THREE.MeshBasicMaterial({\n        map: texture\n      });\n      mesh = new THREE.Mesh(geometry, material);\n      scene.add(mesh);\n      updateUvTransform();\n      animate();\n    });\n    window.addEventListener(\"resize\", onWindowResize, false);\n  } // our scale of the pattern\n\n\n  var repeatX = 0;\n  var repeatY = 0; // var frameCount = 0;\n\n  function animate() {\n    // call animate recursively\n    requestAnimationFrame(animate); // texture manipulation\n\n    var texture = mesh.material.map; // frameCount += 1;\n\n    repeatX += 0.01;\n    repeatY += 0.01;\n    texture.rotation += 0.0001;\n    texture.repeat = {\n      x: repeatX,\n      y: repeatY\n    }; // increase the mesh's rotation each frame\n\n    mesh.rotation.z += 0.0008;\n    mesh.rotation.x += 0.0008;\n    mesh.rotation.y += 0.0008; // render, or 'create a still image', of the scene\n    // this will create one still image / frame each time the animate\n    // function calls itself\n\n    renderer.render(scene, camera);\n  }\n\n  function render() {\n    renderer.render(scene, camera);\n  }\n\n  function onWindowResize() {\n    camera.aspect = window.innerWidth / window.innerHeight;\n    camera.updateProjectionMatrix();\n    renderer.setSize(window.innerWidth, window.innerHeight);\n    render();\n  }\n\n  function updateUvTransform() {\n    var texture = mesh.material.map;\n\n    if (texture.matrixAutoUpdate === true) {\n      texture.offset.set(API.offsetX, API.offsetY); // texture.repeat.set(API.repeatX, API.repeatY);\n\n      texture.center.set(API.centerX, API.centerY); // texture.rotation = API.rotation; // rotation is around [ 0.5, 0.5 ]\n    } else {\n      // one way...\n      //texture.matrix.setUvTransform( API.offsetX, API.offsetY, API.repeatX, API.repeatY, API.rotation, API.centerX, API.centerY );\n      // another way...\n      texture.matrix.identity().translate(-API.centerX, -API.centerY).translate(API.centerX, API.centerY).translate(API.offsetX, API.offsetY);\n    }\n\n    render();\n  }\n};","map":null,"metadata":{},"sourceType":"module"}