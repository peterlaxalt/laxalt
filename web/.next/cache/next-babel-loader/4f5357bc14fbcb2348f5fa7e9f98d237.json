{"ast":null,"code":"function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n// ____________________________________________________________________________________\n\n/**\n *\n * @name WaterTexture\n * @see https://tympanus.net/codrops/2019/10/08/creating-a-water-like-distortion-effect-with-three-js/\n *\n */\nexport class WaterTexture {\n  // _________________________________\n  // Types\n  // _________________________________\n  // Constructor\n  constructor(options) {\n    _defineProperty(this, \"size\", void 0);\n\n    _defineProperty(this, \"radius\", void 0);\n\n    _defineProperty(this, \"width\", void 0);\n\n    _defineProperty(this, \"height\", void 0);\n\n    _defineProperty(this, \"canvas\", void 0);\n\n    _defineProperty(this, \"ctx\", void 0);\n\n    _defineProperty(this, \"debug\", void 0);\n\n    _defineProperty(this, \"points\", void 0);\n\n    _defineProperty(this, \"maxAge\", void 0);\n\n    _defineProperty(this, \"last\", void 0);\n\n    this.size = 64;\n    this.radius = this.size * 0.1;\n    this.width = this.height = this.size;\n    this.size = 64;\n    this.radius = this.size * 0.1;\n    this.points = [];\n    this.maxAge = 64;\n    this.last = null;\n\n    if (options.debug) {\n      this.width = window.innerWidth;\n      this.height = window.innerHeight;\n      this.radius = this.width * 0.05;\n    }\n\n    this.initTexture();\n    if (options.debug) document.body.append(this.canvas);\n  }\n  /**\n   *\n   * @description Initialize our canvas\n   *\n   */\n\n\n  initTexture() {\n    this.canvas = document.createElement(\"canvas\");\n    this.canvas.id = \"WaterTexture\";\n    this.canvas.width = this.width;\n    this.canvas.height = this.height;\n    this.ctx = this.canvas.getContext(\"2d\");\n    this.clear();\n  }\n  /**\n   *\n   * @description Note that addPoint() receives normalized values, from 0 to 1.\n   * If the canvas happens to resize, we can use the normalized points to draw using the correct size.\n   *\n   */\n\n\n  addPoint(point) {\n    let force = 0;\n    let vx = 0;\n    let vy = 0;\n    const last = this.last;\n\n    if (last) {\n      const relativeX = point.x - last.x;\n      const relativeY = point.y - last.y; // Distance formula\n\n      const distanceSquared = relativeX * relativeX + relativeY * relativeY;\n      const distance = Math.sqrt(distanceSquared); // Calculate Unit Vector\n\n      vx = relativeX / distance;\n      vy = relativeY / distance;\n      force = Math.min(distanceSquared * 10000, 1);\n    }\n\n    this.last = {\n      x: point.x,\n      y: point.y\n    };\n    this.points.push({\n      x: point.x,\n      y: point.y,\n      age: 0,\n      force,\n      vx,\n      vy\n    });\n  }\n  /**\n   *\n   * @description Let’s create drawPoint(point) to start drawing the ripples:\n   * Convert the normalized point coordinates into canvas coordinates. Then, draw a happy little circle.\n   *\n   */\n\n\n  drawPoint(point) {\n    // Convert normalized position into canvas coordinates\n    let pos = {\n      x: point.x * this.width,\n      y: point.y * this.height\n    };\n    const radius = this.radius;\n    this.ctx.beginPath();\n    this.ctx.arc(pos.x, pos.y, radius, 0, Math.PI * 2);\n    this.ctx.fill();\n    const ctx = this.ctx; // Lower the opacity as it gets older\n\n    let intensity = 1;\n    intensity = 1 - point.age / this.maxAge;\n    let color = \"255,255,255\";\n    let offset = this.width * 5; // 1. Give the shadow a high offset.\n\n    ctx.shadowOffsetX = offset;\n    ctx.shadowOffsetY = offset;\n    ctx.shadowBlur = radius * 1;\n    ctx.shadowColor = `rgba(${color},${0.2 * intensity})`;\n    this.ctx.beginPath();\n    this.ctx.fillStyle = \"rgba(255,0,0,1)\"; // 2. Move the circle to the other direction of the offset\n\n    this.ctx.arc(pos.x - offset, pos.y - offset, radius, 0, Math.PI * 2);\n    this.ctx.fill();\n  }\n\n  clear() {\n    this.ctx.fillStyle = \"black\";\n    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);\n  }\n\n  update() {\n    this.clear();\n    let agePart = 1 / this.maxAge;\n    this.points.forEach((point, i) => {\n      let slowAsOlder = 1 - point.age / this.maxAge;\n      let force = point.force * agePart * slowAsOlder;\n      point.x += point.vx * force;\n      point.y += point.vy * force;\n      point.age += 1;\n\n      if (point.age > this.maxAge) {\n        this.points.splice(i, 1);\n      }\n    });\n    this.points.forEach(point => {\n      this.drawPoint(point);\n    });\n  }\n\n}","map":{"version":3,"sources":["/Users/pflaxalt/Repositories/_pfl/web/sketches/three/water-distort/WaterTexture.ts"],"names":["WaterTexture","constructor","options","size","radius","width","height","points","maxAge","last","debug","window","innerWidth","innerHeight","initTexture","document","body","append","canvas","createElement","id","ctx","getContext","clear","addPoint","point","force","vx","vy","relativeX","x","relativeY","y","distanceSquared","distance","Math","sqrt","min","push","age","drawPoint","pos","beginPath","arc","PI","fill","intensity","color","offset","shadowOffsetX","shadowOffsetY","shadowBlur","shadowColor","fillStyle","fillRect","update","agePart","forEach","i","slowAsOlder","splice"],"mappings":"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","sourcesContent":["// ____________________________________________________________________________________\n\nexport type LXLT_WaterTextureOptions = {\n  debug?: boolean;\n};\n\nexport type LXLT_WaterTexturePoint = {\n  x: number;\n  y: number;\n  age?: number;\n  force?: number;\n  vx?: number;\n  vy?: number;\n};\n\n/**\n *\n * @name WaterTexture\n * @see https://tympanus.net/codrops/2019/10/08/creating-a-water-like-distortion-effect-with-three-js/\n *\n */\n\nexport class WaterTexture {\n  // _________________________________\n  // Types\n  size: number;\n  radius: number;\n  width: number;\n  height: number;\n  canvas: HTMLCanvasElement;\n  ctx: CanvasRenderingContext2D;\n  debug?: boolean;\n  points: LXLT_WaterTexturePoint[];\n  maxAge: number;\n  last: LXLT_WaterTexturePoint;\n\n  // _________________________________\n  // Constructor\n  constructor(options: LXLT_WaterTextureOptions) {\n    this.size = 64;\n    this.radius = this.size * 0.1;\n    this.width = this.height = this.size;\n\n    this.size = 64;\n    this.radius = this.size * 0.1;\n\n    this.points = [];\n    this.maxAge = 64;\n\n    this.last = null;\n\n    if (options.debug) {\n      this.width = window.innerWidth;\n      this.height = window.innerHeight;\n      this.radius = this.width * 0.05;\n    }\n\n    this.initTexture();\n    if (options.debug) document.body.append(this.canvas);\n  }\n\n  /**\n   *\n   * @description Initialize our canvas\n   *\n   */\n  initTexture() {\n    this.canvas = document.createElement(\"canvas\");\n    this.canvas.id = \"WaterTexture\";\n    this.canvas.width = this.width;\n    this.canvas.height = this.height;\n    this.ctx = this.canvas.getContext(\"2d\");\n    this.clear();\n  }\n\n  /**\n   *\n   * @description Note that addPoint() receives normalized values, from 0 to 1.\n   * If the canvas happens to resize, we can use the normalized points to draw using the correct size.\n   *\n   */\n\n  addPoint(point: LXLT_WaterTexturePoint) {\n    let force = 0;\n    let vx = 0;\n    let vy = 0;\n    const last = this.last;\n    if (last) {\n      const relativeX = point.x - last.x;\n      const relativeY = point.y - last.y;\n      // Distance formula\n      const distanceSquared = relativeX * relativeX + relativeY * relativeY;\n      const distance = Math.sqrt(distanceSquared);\n      // Calculate Unit Vector\n      vx = relativeX / distance;\n      vy = relativeY / distance;\n\n      force = Math.min(distanceSquared * 10000, 1);\n    }\n\n    this.last = {\n      x: point.x,\n      y: point.y,\n    };\n    this.points.push({ x: point.x, y: point.y, age: 0, force, vx, vy });\n  }\n\n  /**\n   *\n   * @description Let’s create drawPoint(point) to start drawing the ripples:\n   * Convert the normalized point coordinates into canvas coordinates. Then, draw a happy little circle.\n   *\n   */\n  drawPoint(point: LXLT_WaterTexturePoint) {\n    // Convert normalized position into canvas coordinates\n    let pos = {\n      x: point.x * this.width,\n      y: point.y * this.height,\n    };\n    const radius = this.radius;\n\n    this.ctx.beginPath();\n    this.ctx.arc(pos.x, pos.y, radius, 0, Math.PI * 2);\n    this.ctx.fill();\n\n    const ctx = this.ctx;\n    // Lower the opacity as it gets older\n    let intensity = 1;\n    intensity = 1 - point.age / this.maxAge;\n\n    let color = \"255,255,255\";\n\n    let offset = this.width * 5;\n    // 1. Give the shadow a high offset.\n    ctx.shadowOffsetX = offset;\n    ctx.shadowOffsetY = offset;\n    ctx.shadowBlur = radius * 1;\n    ctx.shadowColor = `rgba(${color},${0.2 * intensity})`;\n\n    this.ctx.beginPath();\n    this.ctx.fillStyle = \"rgba(255,0,0,1)\";\n    // 2. Move the circle to the other direction of the offset\n    this.ctx.arc(pos.x - offset, pos.y - offset, radius, 0, Math.PI * 2);\n    this.ctx.fill();\n  }\n\n  clear() {\n    this.ctx.fillStyle = \"black\";\n    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);\n  }\n\n  update() {\n    this.clear();\n    let agePart = 1 / this.maxAge;\n    this.points.forEach((point, i) => {\n      let slowAsOlder = 1 - point.age / this.maxAge;\n      let force = point.force * agePart * slowAsOlder;\n      point.x += point.vx * force;\n      point.y += point.vy * force;\n      point.age += 1;\n      if (point.age > this.maxAge) {\n        this.points.splice(i, 1);\n      }\n    });\n    this.points.forEach((point) => {\n      this.drawPoint(point);\n    });\n  }\n}\n"]},"metadata":{},"sourceType":"module"}