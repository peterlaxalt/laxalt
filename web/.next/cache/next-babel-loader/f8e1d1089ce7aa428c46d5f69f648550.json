{"ast":null,"code":"import * as THREE from \"three\";\nimport { __DEBUG__ } from \"../../constants/site/Settings\";\nexport var ThreeCanvas = function ThreeCanvas(container, CanvasElement, CanvasTheme) {\n  __DEBUG__ && console.log(\"ðŸ¤™ Three.js Canvas received:\", CanvasElement);\n  var renderer, scene, camera, sketch, ctx; // @ts-ignore\n\n  renderer = new THREE.WebGLRenderer({\n    container: container\n  });\n  sketch = container;\n  renderer.setPixelRatio(window.devicePixelRatio);\n  renderer.setSize(window.innerWidth, window.innerHeight);\n  sketch.appendChild(renderer.domElement);\n  ctx = CanvasElement.getContext(\"2d\");\n  var fov = 75;\n  var aspect = 2; // the canvas default\n\n  var near = 0.1;\n  var far = 5;\n  camera = new THREE.PerspectiveCamera(fov, aspect, near, far);\n  camera.position.z = 2;\n  scene = new THREE.Scene();\n  var boxWidth = 1;\n  var boxHeight = 1;\n  var boxDepth = 1;\n  var geometry = new THREE.BoxGeometry(boxWidth, boxHeight, boxDepth);\n  var cubes = []; // just an array we can use to rotate the cubes\n\n  var texture = new THREE.CanvasTexture(ctx.canvas);\n  texture.needsUpdate = true;\n  var material = new THREE.MeshBasicMaterial({\n    map: texture\n  });\n  var cube = new THREE.Mesh(geometry, material);\n  scene.add(cube);\n  scene.background = new THREE.Color(0x0d132a);\n  cubes.push(cube); // add to our list of cubes to rotate\n\n  function resizeRendererToDisplaySize(renderer) {\n    var canvas = renderer.domElement;\n    var width = canvas.clientWidth;\n    var height = canvas.clientHeight;\n    var needResize = canvas.width !== width || canvas.height !== height;\n\n    if (needResize) {\n      renderer.setSize(width, height, false);\n    }\n\n    return needResize;\n  }\n\n  function render(time) {\n    time *= 0.001;\n\n    if (resizeRendererToDisplaySize(renderer)) {\n      var canvas = renderer.domElement;\n      camera.aspect = canvas.clientWidth / canvas.clientHeight;\n      camera.updateProjectionMatrix();\n    }\n\n    texture.needsUpdate = true;\n    cubes.forEach(function (cube, ndx) {\n      var speed = 0.2 + ndx * 0.1;\n      var rot = time * speed;\n      cube.rotation.x = rot;\n      cube.rotation.y = rot;\n    });\n    renderer.render(scene, camera);\n    requestAnimationFrame(render);\n  }\n\n  requestAnimationFrame(render);\n};\n_c = ThreeCanvas;\n\nvar _c;\n\n$RefreshReg$(_c, \"ThreeCanvas\");","map":{"version":3,"sources":["/Users/pflaxalt/Repositories/_pfl/web/sketches/three/with-canvas-as-texture.ts"],"names":["THREE","__DEBUG__","ThreeCanvas","container","CanvasElement","CanvasTheme","console","log","renderer","scene","camera","sketch","ctx","WebGLRenderer","setPixelRatio","window","devicePixelRatio","setSize","innerWidth","innerHeight","appendChild","domElement","getContext","fov","aspect","near","far","PerspectiveCamera","position","z","Scene","boxWidth","boxHeight","boxDepth","geometry","BoxGeometry","cubes","texture","CanvasTexture","canvas","needsUpdate","material","MeshBasicMaterial","map","cube","Mesh","add","background","Color","push","resizeRendererToDisplaySize","width","clientWidth","height","clientHeight","needResize","render","time","updateProjectionMatrix","forEach","ndx","speed","rot","rotation","x","y","requestAnimationFrame"],"mappings":"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","sourcesContent":["import * as THREE from \"three\";\nimport { __DEBUG__ } from \"../../constants/site/Settings\";\nimport { LXLT_ColorTheme } from \"../../constants/styles/Color\";\n\n// Begin Component\n// __________________________________________________________________________\n\nexport type LXLT_ThreeCanvasDisplay = (\n  container: HTMLDivElement,\n  CanvasElement: HTMLCanvasElement,\n  CanvasTheme: LXLT_ColorTheme\n) => void;\n\nexport const ThreeCanvas: LXLT_ThreeCanvasDisplay = (\n  container,\n  CanvasElement,\n  CanvasTheme\n) => {\n  __DEBUG__ && console.log(\"ðŸ¤™ Three.js Canvas received:\", CanvasElement);\n  var renderer, scene, camera, sketch, ctx;\n\n  // @ts-ignore\n  renderer = new THREE.WebGLRenderer({ container });\n\n  sketch = container;\n  renderer.setPixelRatio(window.devicePixelRatio);\n  renderer.setSize(window.innerWidth, window.innerHeight);\n  sketch.appendChild(renderer.domElement);\n\n  ctx = CanvasElement.getContext(\"2d\");\n\n  const fov = 75;\n  const aspect = 2; // the canvas default\n  const near = 0.1;\n  const far = 5;\n  camera = new THREE.PerspectiveCamera(fov, aspect, near, far);\n  camera.position.z = 2;\n  scene = new THREE.Scene();\n  const boxWidth = 1;\n  const boxHeight = 1;\n  const boxDepth = 1;\n\n  const geometry = new THREE.BoxGeometry(boxWidth, boxHeight, boxDepth);\n  const cubes = []; // just an array we can use to rotate the cubes\n\n  const texture = new THREE.CanvasTexture(ctx.canvas);\n  texture.needsUpdate = true;\n\n  const material = new THREE.MeshBasicMaterial({\n    map: texture,\n  });\n  const cube = new THREE.Mesh(geometry, material);\n\n  scene.add(cube);\n  scene.background = new THREE.Color(0x0d132a);\n\n  cubes.push(cube); // add to our list of cubes to rotate\n  function resizeRendererToDisplaySize(renderer) {\n    const canvas = renderer.domElement;\n    const width = canvas.clientWidth;\n    const height = canvas.clientHeight;\n    const needResize = canvas.width !== width || canvas.height !== height;\n    if (needResize) {\n      renderer.setSize(width, height, false);\n    }\n    return needResize;\n  }\n  function render(time) {\n    time *= 0.001;\n    if (resizeRendererToDisplaySize(renderer)) {\n      const canvas = renderer.domElement;\n      camera.aspect = canvas.clientWidth / canvas.clientHeight;\n      camera.updateProjectionMatrix();\n    }\n    texture.needsUpdate = true;\n    cubes.forEach((cube, ndx) => {\n      const speed = 0.2 + ndx * 0.1;\n      const rot = time * speed;\n      cube.rotation.x = rot;\n      cube.rotation.y = rot;\n    });\n    renderer.render(scene, camera);\n    requestAnimationFrame(render);\n  }\n  requestAnimationFrame(render);\n};\n"]},"metadata":{},"sourceType":"module"}