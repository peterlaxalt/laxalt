{"ast":null,"code":"import * as THREE from \"three\";\nexport const ThreeCanvas = (container, CanvasTheme) => {\n  const canvas = document.querySelector(\"#defaultCanvas0\"); // @ts-ignore\n\n  const renderer = new THREE.WebGLRenderer({\n    canvas\n  });\n  const fov = 75;\n  const aspect = 2; // the canvas default\n\n  const near = 0.1;\n  const far = 5;\n  const camera = new THREE.PerspectiveCamera(fov, aspect, near, far);\n  camera.position.z = 2;\n  const scene = new THREE.Scene();\n  const boxWidth = 1;\n  const boxHeight = 1;\n  const boxDepth = 1;\n  const geometry = new THREE.BoxGeometry(boxWidth, boxHeight, boxDepth);\n  const cubes = []; // just an array we can use to rotate the cubes\n\n  const loader = new THREE.TextureLoader();\n  const material = new THREE.MeshBasicMaterial({\n    map: loader.load(\"https://threejsfundamentals.org/threejs/resources/images/wall.jpg\")\n  });\n  const cube = new THREE.Mesh(geometry, material);\n  scene.add(cube);\n  cubes.push(cube); // add to our list of cubes to rotate\n\n  function resizeRendererToDisplaySize(renderer) {\n    const canvas = renderer.domElement;\n    const width = canvas.clientWidth;\n    const height = canvas.clientHeight;\n    const needResize = canvas.width !== width || canvas.height !== height;\n\n    if (needResize) {\n      renderer.setSize(width, height, false);\n    }\n\n    return needResize;\n  }\n\n  function render(time) {\n    time *= 0.001;\n\n    if (resizeRendererToDisplaySize(renderer)) {\n      const canvas = renderer.domElement;\n      camera.aspect = canvas.clientWidth / canvas.clientHeight;\n      camera.updateProjectionMatrix();\n    }\n\n    cubes.forEach((cube, ndx) => {\n      const speed = 0.2 + ndx * 0.1;\n      const rot = time * speed;\n      cube.rotation.x = rot;\n      cube.rotation.y = rot;\n    });\n    renderer.render(scene, camera);\n    requestAnimationFrame(render);\n  }\n\n  requestAnimationFrame(render);\n};","map":{"version":3,"sources":["/Users/pflaxalt/Repositories/_pfl/web/sketches/three/with-canvas-as-texture.ts"],"names":["THREE","ThreeCanvas","container","CanvasTheme","canvas","document","querySelector","renderer","WebGLRenderer","fov","aspect","near","far","camera","PerspectiveCamera","position","z","scene","Scene","boxWidth","boxHeight","boxDepth","geometry","BoxGeometry","cubes","loader","TextureLoader","material","MeshBasicMaterial","map","load","cube","Mesh","add","push","resizeRendererToDisplaySize","domElement","width","clientWidth","height","clientHeight","needResize","setSize","render","time","updateProjectionMatrix","forEach","ndx","speed","rot","rotation","x","y","requestAnimationFrame"],"mappings":"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","sourcesContent":["import * as THREE from \"three\";\nimport { LXLT_ColorTheme } from \"../../constants/styles/Color\";\n\n// Begin Component\n// __________________________________________________________________________\n\nexport type LXLT_ThreeCanvasDisplay = (\n  container: HTMLDivElement,\n  CanvasTheme: LXLT_ColorTheme\n) => void;\n\nexport const ThreeCanvas: LXLT_ThreeCanvasDisplay = (\n  container,\n  CanvasTheme\n) => {\n  const canvas: Element = document.querySelector(\"#defaultCanvas0\");\n  // @ts-ignore\n  const renderer = new THREE.WebGLRenderer({ canvas });\n\n  const fov = 75;\n  const aspect = 2; // the canvas default\n  const near = 0.1;\n  const far = 5;\n  const camera = new THREE.PerspectiveCamera(fov, aspect, near, far);\n  camera.position.z = 2;\n\n  const scene = new THREE.Scene();\n\n  const boxWidth = 1;\n  const boxHeight = 1;\n  const boxDepth = 1;\n  const geometry = new THREE.BoxGeometry(boxWidth, boxHeight, boxDepth);\n\n  const cubes = []; // just an array we can use to rotate the cubes\n  const loader = new THREE.TextureLoader();\n\n  const material = new THREE.MeshBasicMaterial({\n    map: loader.load(\n      \"https://threejsfundamentals.org/threejs/resources/images/wall.jpg\"\n    ),\n  });\n  const cube = new THREE.Mesh(geometry, material);\n  scene.add(cube);\n  cubes.push(cube); // add to our list of cubes to rotate\n\n  function resizeRendererToDisplaySize(renderer) {\n    const canvas = renderer.domElement;\n    const width = canvas.clientWidth;\n    const height = canvas.clientHeight;\n    const needResize = canvas.width !== width || canvas.height !== height;\n    if (needResize) {\n      renderer.setSize(width, height, false);\n    }\n    return needResize;\n  }\n\n  function render(time) {\n    time *= 0.001;\n\n    if (resizeRendererToDisplaySize(renderer)) {\n      const canvas = renderer.domElement;\n      camera.aspect = canvas.clientWidth / canvas.clientHeight;\n      camera.updateProjectionMatrix();\n    }\n\n    cubes.forEach((cube, ndx) => {\n      const speed = 0.2 + ndx * 0.1;\n      const rot = time * speed;\n      cube.rotation.x = rot;\n      cube.rotation.y = rot;\n    });\n\n    renderer.render(scene, camera);\n\n    requestAnimationFrame(render);\n  }\n\n  requestAnimationFrame(render);\n};\n"]},"metadata":{},"sourceType":"module"}