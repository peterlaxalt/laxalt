{"ast":null,"code":"import { __DEBUG__ } from \"../../constants/site/Settings\";\nexport const ThreeCanvas = (container, CanvasElement, CanvasTheme) => {\n  __DEBUG__ && console.log(\"ðŸ¤™ Three.js Canvas received:\", CanvasElement); // var renderer, scene, camera, sketch;\n  // const canvas: HTMLCanvasElement = document.getElementById(\n  //   \"defaultCanvas0\"\n  // ) as HTMLCanvasElement;\n  // renderer = new THREE.WebGLRenderer({ canvas });\n  // sketch = container;\n  // renderer.setPixelRatio(window.devicePixelRatio);\n  // renderer.setSize(window.innerWidth, window.innerHeight);\n  // sketch.appendChild(renderer.domElement);\n  // const fov = 75;\n  // const aspect = 2; // the canvas default\n  // const near = 0.1;\n  // const far = 5;\n  // camera = new THREE.PerspectiveCamera(fov, aspect, near, far);\n  // camera.position.z = 2;\n  // scene = new THREE.Scene();\n  // const boxWidth = 1;\n  // const boxHeight = 1;\n  // const boxDepth = 1;\n  // const geometry = new THREE.BoxGeometry(boxWidth, boxHeight, boxDepth);\n  // const cubes = []; // just an array we can use to rotate the cubes\n  // // @ts-ignore\n  // const texture = new THREE.CanvasTexture(canvas);\n  // const material = new THREE.MeshBasicMaterial({\n  //   map: texture,\n  // });\n  // const cube = new THREE.Mesh(geometry, material);\n  // scene.add(cube);\n  // cubes.push(cube); // add to our list of cubes to rotate\n  // function resizeRendererToDisplaySize(renderer) {\n  //   const canvas = renderer.domElement;\n  //   const width = canvas.clientWidth;\n  //   const height = canvas.clientHeight;\n  //   const needResize = canvas.width !== width || canvas.height !== height;\n  //   if (needResize) {\n  //     renderer.setSize(width, height, false);\n  //   }\n  //   return needResize;\n  // }\n  // function render(time) {\n  //   time *= 0.001;\n  //   if (resizeRendererToDisplaySize(renderer)) {\n  //     const canvas = renderer.domElement;\n  //     camera.aspect = canvas.clientWidth / canvas.clientHeight;\n  //     camera.updateProjectionMatrix();\n  //   }\n  //   texture.needsUpdate = true;\n  //   cubes.forEach((cube, ndx) => {\n  //     const speed = 0.2 + ndx * 0.1;\n  //     const rot = time * speed;\n  //     cube.rotation.x = rot;\n  //     cube.rotation.y = rot;\n  //   });\n  //   renderer.render(scene, camera);\n  //   requestAnimationFrame(render);\n  // }\n  // requestAnimationFrame(render);\n};","map":{"version":3,"sources":["/Users/pflaxalt/Repositories/_pfl/web/sketches/three/with-canvas-as-texture.ts"],"names":["__DEBUG__","ThreeCanvas","container","CanvasElement","CanvasTheme","console","log"],"mappings":"AACA,SAASA,SAAT,QAA0B,+BAA1B;AAYA,OAAO,MAAMC,WAAoC,GAAG,CAClDC,SADkD,EAElDC,aAFkD,EAGlDC,WAHkD,KAI/C;AACHJ,EAAAA,SAAS,IAAIK,OAAO,CAACC,GAAR,CAAY,8BAAZ,EAA4CH,aAA5C,CAAb,CADG,CAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACD,CA/DM","sourcesContent":["import * as THREE from \"three\";\nimport { __DEBUG__ } from \"../../constants/site/Settings\";\nimport { LXLT_ColorTheme } from \"../../constants/styles/Color\";\n\n// Begin Component\n// __________________________________________________________________________\n\nexport type LXLT_ThreeCanvasDisplay = (\n  container: HTMLDivElement,\n  CanvasElement: HTMLCanvasElement,\n  CanvasTheme: LXLT_ColorTheme\n) => void;\n\nexport const ThreeCanvas: LXLT_ThreeCanvasDisplay = (\n  container,\n  CanvasElement,\n  CanvasTheme\n) => {\n  __DEBUG__ && console.log(\"ðŸ¤™ Three.js Canvas received:\", CanvasElement);\n  // var renderer, scene, camera, sketch;\n  // const canvas: HTMLCanvasElement = document.getElementById(\n  //   \"defaultCanvas0\"\n  // ) as HTMLCanvasElement;\n  // renderer = new THREE.WebGLRenderer({ canvas });\n  // sketch = container;\n  // renderer.setPixelRatio(window.devicePixelRatio);\n  // renderer.setSize(window.innerWidth, window.innerHeight);\n  // sketch.appendChild(renderer.domElement);\n  // const fov = 75;\n  // const aspect = 2; // the canvas default\n  // const near = 0.1;\n  // const far = 5;\n  // camera = new THREE.PerspectiveCamera(fov, aspect, near, far);\n  // camera.position.z = 2;\n  // scene = new THREE.Scene();\n  // const boxWidth = 1;\n  // const boxHeight = 1;\n  // const boxDepth = 1;\n  // const geometry = new THREE.BoxGeometry(boxWidth, boxHeight, boxDepth);\n  // const cubes = []; // just an array we can use to rotate the cubes\n  // // @ts-ignore\n  // const texture = new THREE.CanvasTexture(canvas);\n  // const material = new THREE.MeshBasicMaterial({\n  //   map: texture,\n  // });\n  // const cube = new THREE.Mesh(geometry, material);\n  // scene.add(cube);\n  // cubes.push(cube); // add to our list of cubes to rotate\n  // function resizeRendererToDisplaySize(renderer) {\n  //   const canvas = renderer.domElement;\n  //   const width = canvas.clientWidth;\n  //   const height = canvas.clientHeight;\n  //   const needResize = canvas.width !== width || canvas.height !== height;\n  //   if (needResize) {\n  //     renderer.setSize(width, height, false);\n  //   }\n  //   return needResize;\n  // }\n  // function render(time) {\n  //   time *= 0.001;\n  //   if (resizeRendererToDisplaySize(renderer)) {\n  //     const canvas = renderer.domElement;\n  //     camera.aspect = canvas.clientWidth / canvas.clientHeight;\n  //     camera.updateProjectionMatrix();\n  //   }\n  //   texture.needsUpdate = true;\n  //   cubes.forEach((cube, ndx) => {\n  //     const speed = 0.2 + ndx * 0.1;\n  //     const rot = time * speed;\n  //     cube.rotation.x = rot;\n  //     cube.rotation.y = rot;\n  //   });\n  //   renderer.render(scene, camera);\n  //   requestAnimationFrame(render);\n  // }\n  // requestAnimationFrame(render);\n};\n"]},"metadata":{},"sourceType":"module"}