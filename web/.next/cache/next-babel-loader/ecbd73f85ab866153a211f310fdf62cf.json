{"ast":null,"code":"import * as THREE from \"three\";\nimport { ColorContext_Defaults } from \"../../constants/styles/Color\";\nimport { hexToRGB } from \"../../utils/hexToRGB\"; // import { GUI } from \"./jsm/libs/dat.gui.module.js\";\n\nimport { OrbitControls } from \"./jsm/controls/OrbitControls.js\"; // Begin Component\n// __________________________________________________________________________\n\nexport var ThreeCanvas = function ThreeCanvas(container) {\n  /**\n   * Setup\n   */\n  console.log(\"CanvasTheme\", ColorContext_Defaults);\n  var mesh, renderer, scene, camera, controls, sketch; // var gui;\n\n  var API = {\n    offsetX: 0,\n    offsetY: 0,\n    repeatX: 0.25,\n    repeatY: 0.25,\n    rotation: Math.PI / 4,\n    // positive is counter-clockwise\n    centerX: 0.5,\n    centerY: 0.5\n  };\n  init();\n\n  function init() {\n    renderer = new THREE.WebGLRenderer();\n    sketch = container;\n    renderer.setPixelRatio(window.devicePixelRatio);\n    renderer.setSize(window.innerWidth, window.innerHeight);\n    sketch.appendChild(renderer.domElement);\n    scene = new THREE.Scene();\n    camera = new THREE.PerspectiveCamera(40, window.innerWidth / window.innerHeight, 1, 1000);\n    camera.position.set(0, 0, 25);\n    scene.background = new THREE.Color(\"\".concat(hexToRGB(themeContext.background, 1)));\n    scene.add(camera);\n    /**\n     * Camera controls\n     */\n\n    controls = new OrbitControls(camera, renderer.domElement);\n    controls.movementSpeed = 10000;\n    controls.domElement = renderer.domElement;\n    controls.rollSpeed = Math.PI / 24;\n    controls.autoForward = true;\n    controls.dragToLook = true;\n    controls.enableZoom = false;\n    var geometry = new THREE.TorusKnotBufferGeometry(10, 3, 200, 200);\n    new THREE.TextureLoader().load(\"/projects/three/stripe-tile.png\", function (texture) {\n      texture.wrapS = texture.wrapT = THREE.RepeatWrapping; // texture.anisotropy = renderer.capabilities.getMaxAnisotropy();\n\n      texture.anisotropy = 1; //texture.matrixAutoUpdate = false; // default true; set to false to update texture.matrix manually\n\n      var material = new THREE.MeshBasicMaterial({\n        map: texture\n      });\n      mesh = new THREE.Mesh(geometry, material);\n      scene.add(mesh);\n      updateUvTransform();\n      animate();\n    });\n    window.addEventListener(\"resize\", onWindowResize, false);\n  } // our scale of the pattern\n\n\n  var repeatX = 0;\n  var repeatY = 0; // var frameCount = 0;\n\n  function animate() {\n    // call animate recursively\n    requestAnimationFrame(animate); // texture manipulation\n\n    var texture = mesh.material.map; // frameCount += 1;\n\n    repeatX += 0.01;\n    repeatY += 0.01; // if (repeatX < 13) {\n    //   repeatX += 0.01;\n    //   repeatY += 0.01;\n    // } else {\n    //   repeatX += 0.001;\n    //   repeatY += 0.001;\n    // }\n    // else {\n    //   if (repeatY < 60) {\n    //     repeatY += 0.05;\n    //   } else {\n    //     repeatX += 0.05;\n    //   }\n    // }\n    // console.log(\n    //   \"repeatX: \" +\n    //     repeatX +\n    //     \", repeatY: \" +\n    //     repeatY +\n    //     \", frameCount: \" +\n    //     frameCount\n    // );\n    // console.log(texture);\n\n    texture.rotation += 0.0001;\n    texture.repeat = {\n      x: repeatX,\n      y: repeatY\n    }; // increase the mesh's rotation each frame\n\n    mesh.rotation.z += 0.0008;\n    mesh.rotation.x += 0.0008;\n    mesh.rotation.y += 0.0008; // render, or 'create a still image', of the scene\n    // this will create one still image / frame each time the animate\n    // function calls itself\n\n    renderer.render(scene, camera);\n  }\n\n  function render() {\n    renderer.render(scene, camera);\n  }\n\n  function onWindowResize() {\n    camera.aspect = window.innerWidth / window.innerHeight;\n    camera.updateProjectionMatrix();\n    renderer.setSize(window.innerWidth, window.innerHeight);\n    render();\n  }\n\n  function updateUvTransform() {\n    var texture = mesh.material.map;\n\n    if (texture.matrixAutoUpdate === true) {\n      texture.offset.set(API.offsetX, API.offsetY); // texture.repeat.set(API.repeatX, API.repeatY);\n\n      texture.center.set(API.centerX, API.centerY); // texture.rotation = API.rotation; // rotation is around [ 0.5, 0.5 ]\n    } else {\n      // one way...\n      //texture.matrix.setUvTransform( API.offsetX, API.offsetY, API.repeatX, API.repeatY, API.rotation, API.centerX, API.centerY );\n      // another way...\n      texture.matrix.identity().translate(-API.centerX, -API.centerY) // .rotate(API.rotation) // I don't understand how rotation can preceed scale, but it seems to be required...\n      // .scale(API.repeatX, API.repeatY)\n      .translate(API.centerX, API.centerY).translate(API.offsetX, API.offsetY);\n    }\n\n    render();\n  } // function initGui() {\n  //   gui = new GUI();\n  //   gui\n  //     .add(API, \"offsetX\", 0.0, 1.0)\n  //     .name(\"offset.x\")\n  //     .onChange(updateUvTransform);\n  //   gui\n  //     .add(API, \"offsetY\", 0.0, 1.0)\n  //     .name(\"offset.y\")\n  //     .onChange(updateUvTransform);\n  //   // gui\n  //   //   .add(API, \"repeatX\", 0.25, 2.0)\n  //   //   .name(\"repeat.x\")\n  //   //   .onChange(updateUvTransform);\n  //   // gui\n  //   //   .add(API, \"repeatY\", 0.25, 2.0)\n  //   //   .name(\"repeat.y\")\n  //   //   .onChange(updateUvTransform);\n  //   // gui\n  //   //   .add(API, \"rotation\", -2.0, 2.0)\n  //   //   .name(\"rotation\")\n  //   //   .onChange(updateUvTransform);\n  //   gui\n  //     .add(API, \"centerX\", 0.0, 1.0)\n  //     .name(\"center.x\")\n  //     .onChange(updateUvTransform);\n  //   gui\n  //     .add(API, \"centerY\", 0.0, 1.0)\n  //     .name(\"center.y\")\n  //     .onChange(updateUvTransform);\n  // }\n\n};\n_c = ThreeCanvas;\n\nvar _c;\n\n$RefreshReg$(_c, \"ThreeCanvas\");","map":{"version":3,"sources":["/Users/pflaxalt/Repositories/_pfl/web/sketches/three/_scaffold-three-canvas.ts"],"names":["THREE","ColorContext_Defaults","hexToRGB","OrbitControls","ThreeCanvas","container","console","log","mesh","renderer","scene","camera","controls","sketch","API","offsetX","offsetY","repeatX","repeatY","rotation","Math","PI","centerX","centerY","init","WebGLRenderer","setPixelRatio","window","devicePixelRatio","setSize","innerWidth","innerHeight","appendChild","domElement","Scene","PerspectiveCamera","position","set","background","Color","themeContext","add","movementSpeed","rollSpeed","autoForward","dragToLook","enableZoom","geometry","TorusKnotBufferGeometry","TextureLoader","load","texture","wrapS","wrapT","RepeatWrapping","anisotropy","material","MeshBasicMaterial","map","Mesh","updateUvTransform","animate","addEventListener","onWindowResize","requestAnimationFrame","repeat","x","y","z","render","aspect","updateProjectionMatrix","matrixAutoUpdate","offset","center","matrix","identity","translate"],"mappings":"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","sourcesContent":["import * as THREE from \"three\";\nimport { ColorContext_Defaults } from \"../../constants/styles/Color\";\nimport { hexToRGB } from \"../../utils/hexToRGB\";\n// import { GUI } from \"./jsm/libs/dat.gui.module.js\";\nimport { OrbitControls } from \"./jsm/controls/OrbitControls.js\";\n\n// Begin Component\n// __________________________________________________________________________\n\nexport type LXLT_ThreeCanvasDisplay = (container: HTMLDivElement) => void;\n\nexport const ThreeCanvas: LXLT_ThreeCanvasDisplay = (container) => {\n  /**\n   * Setup\n   */\n\n  console.log(\"CanvasTheme\", ColorContext_Defaults);\n\n  var mesh, renderer, scene, camera, controls, sketch;\n\n  // var gui;\n\n  var API = {\n    offsetX: 0,\n    offsetY: 0,\n    repeatX: 0.25,\n    repeatY: 0.25,\n    rotation: Math.PI / 4, // positive is counter-clockwise\n    centerX: 0.5,\n    centerY: 0.5,\n  };\n\n  init();\n\n  function init() {\n    renderer = new THREE.WebGLRenderer();\n    sketch = container;\n    renderer.setPixelRatio(window.devicePixelRatio);\n    renderer.setSize(window.innerWidth, window.innerHeight);\n    sketch.appendChild(renderer.domElement);\n\n    scene = new THREE.Scene();\n\n    camera = new THREE.PerspectiveCamera(\n      40,\n      window.innerWidth / window.innerHeight,\n      1,\n      1000\n    );\n    camera.position.set(0, 0, 25);\n\n    scene.background = new THREE.Color(\n      `${hexToRGB(themeContext.background, 1)}`\n    );\n    scene.add(camera);\n\n    /**\n     * Camera controls\n     */\n    controls = new OrbitControls(camera, renderer.domElement);\n    controls.movementSpeed = 10000;\n    controls.domElement = renderer.domElement;\n    controls.rollSpeed = Math.PI / 24;\n    controls.autoForward = true;\n    controls.dragToLook = true;\n    controls.enableZoom = false;\n\n    var geometry = new THREE.TorusKnotBufferGeometry(10, 3, 200, 200);\n\n    new THREE.TextureLoader().load(\n      \"/projects/three/stripe-tile.png\",\n      function (texture) {\n        texture.wrapS = texture.wrapT = THREE.RepeatWrapping;\n        // texture.anisotropy = renderer.capabilities.getMaxAnisotropy();\n        texture.anisotropy = 1;\n\n        //texture.matrixAutoUpdate = false; // default true; set to false to update texture.matrix manually\n\n        var material = new THREE.MeshBasicMaterial({ map: texture });\n\n        mesh = new THREE.Mesh(geometry, material);\n        scene.add(mesh);\n\n        updateUvTransform();\n\n        animate();\n      }\n    );\n\n    window.addEventListener(\"resize\", onWindowResize, false);\n  }\n\n  // our scale of the pattern\n  var repeatX = 0;\n  var repeatY = 0;\n  // var frameCount = 0;\n\n  function animate() {\n    // call animate recursively\n    requestAnimationFrame(animate);\n\n    // texture manipulation\n    var texture = mesh.material.map;\n    // frameCount += 1;\n\n    repeatX += 0.01;\n    repeatY += 0.01;\n\n    // if (repeatX < 13) {\n    //   repeatX += 0.01;\n    //   repeatY += 0.01;\n    // } else {\n    //   repeatX += 0.001;\n    //   repeatY += 0.001;\n    // }\n    // else {\n    //   if (repeatY < 60) {\n    //     repeatY += 0.05;\n    //   } else {\n    //     repeatX += 0.05;\n    //   }\n    // }\n\n    // console.log(\n    //   \"repeatX: \" +\n    //     repeatX +\n    //     \", repeatY: \" +\n    //     repeatY +\n    //     \", frameCount: \" +\n    //     frameCount\n    // );\n\n    // console.log(texture);\n    texture.rotation += 0.0001;\n    texture.repeat = { x: repeatX, y: repeatY };\n\n    // increase the mesh's rotation each frame\n    mesh.rotation.z += 0.0008;\n    mesh.rotation.x += 0.0008;\n    mesh.rotation.y += 0.0008;\n\n    // render, or 'create a still image', of the scene\n    // this will create one still image / frame each time the animate\n    // function calls itself\n    renderer.render(scene, camera);\n  }\n\n  function render() {\n    renderer.render(scene, camera);\n  }\n\n  function onWindowResize() {\n    camera.aspect = window.innerWidth / window.innerHeight;\n\n    camera.updateProjectionMatrix();\n\n    renderer.setSize(window.innerWidth, window.innerHeight);\n\n    render();\n  }\n\n  function updateUvTransform() {\n    var texture = mesh.material.map;\n\n    if (texture.matrixAutoUpdate === true) {\n      texture.offset.set(API.offsetX, API.offsetY);\n      // texture.repeat.set(API.repeatX, API.repeatY);\n      texture.center.set(API.centerX, API.centerY);\n      // texture.rotation = API.rotation; // rotation is around [ 0.5, 0.5 ]\n    } else {\n      // one way...\n      //texture.matrix.setUvTransform( API.offsetX, API.offsetY, API.repeatX, API.repeatY, API.rotation, API.centerX, API.centerY );\n\n      // another way...\n      texture.matrix\n        .identity()\n        .translate(-API.centerX, -API.centerY)\n        // .rotate(API.rotation) // I don't understand how rotation can preceed scale, but it seems to be required...\n        // .scale(API.repeatX, API.repeatY)\n        .translate(API.centerX, API.centerY)\n        .translate(API.offsetX, API.offsetY);\n    }\n\n    render();\n  }\n\n  // function initGui() {\n  //   gui = new GUI();\n\n  //   gui\n  //     .add(API, \"offsetX\", 0.0, 1.0)\n  //     .name(\"offset.x\")\n  //     .onChange(updateUvTransform);\n  //   gui\n  //     .add(API, \"offsetY\", 0.0, 1.0)\n  //     .name(\"offset.y\")\n  //     .onChange(updateUvTransform);\n  //   // gui\n  //   //   .add(API, \"repeatX\", 0.25, 2.0)\n  //   //   .name(\"repeat.x\")\n  //   //   .onChange(updateUvTransform);\n  //   // gui\n  //   //   .add(API, \"repeatY\", 0.25, 2.0)\n  //   //   .name(\"repeat.y\")\n  //   //   .onChange(updateUvTransform);\n  //   // gui\n  //   //   .add(API, \"rotation\", -2.0, 2.0)\n  //   //   .name(\"rotation\")\n  //   //   .onChange(updateUvTransform);\n  //   gui\n  //     .add(API, \"centerX\", 0.0, 1.0)\n  //     .name(\"center.x\")\n  //     .onChange(updateUvTransform);\n  //   gui\n  //     .add(API, \"centerY\", 0.0, 1.0)\n  //     .name(\"center.y\")\n  //     .onChange(updateUvTransform);\n  // }\n};\n"]},"metadata":{},"sourceType":"module"}