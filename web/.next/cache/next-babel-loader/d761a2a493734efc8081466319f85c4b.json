{"ast":null,"code":"// Begin Component\n// __________________________________________________________________________\nexport var ThreeCanvas = function ThreeCanvas(container, CanvasTheme) {// var renderer, scene, camera, sketch;\n  // const canvas: HTMLCanvasElement = document.getElementById(\n  //   \"defaultCanvas0\"\n  // ) as HTMLCanvasElement;\n  // renderer = new THREE.WebGLRenderer({ canvas });\n  // sketch = container;\n  // renderer.setPixelRatio(window.devicePixelRatio);\n  // renderer.setSize(window.innerWidth, window.innerHeight);\n  // sketch.appendChild(renderer.domElement);\n  // const fov = 75;\n  // const aspect = 2; // the canvas default\n  // const near = 0.1;\n  // const far = 5;\n  // camera = new THREE.PerspectiveCamera(fov, aspect, near, far);\n  // camera.position.z = 2;\n  // scene = new THREE.Scene();\n  // const boxWidth = 1;\n  // const boxHeight = 1;\n  // const boxDepth = 1;\n  // const geometry = new THREE.BoxGeometry(boxWidth, boxHeight, boxDepth);\n  // const cubes = []; // just an array we can use to rotate the cubes\n  // // @ts-ignore\n  // const texture = new THREE.CanvasTexture(canvas);\n  // const material = new THREE.MeshBasicMaterial({\n  //   map: texture,\n  // });\n  // const cube = new THREE.Mesh(geometry, material);\n  // scene.add(cube);\n  // cubes.push(cube); // add to our list of cubes to rotate\n  // function resizeRendererToDisplaySize(renderer) {\n  //   const canvas = renderer.domElement;\n  //   const width = canvas.clientWidth;\n  //   const height = canvas.clientHeight;\n  //   const needResize = canvas.width !== width || canvas.height !== height;\n  //   if (needResize) {\n  //     renderer.setSize(width, height, false);\n  //   }\n  //   return needResize;\n  // }\n  // function render(time) {\n  //   time *= 0.001;\n  //   if (resizeRendererToDisplaySize(renderer)) {\n  //     const canvas = renderer.domElement;\n  //     camera.aspect = canvas.clientWidth / canvas.clientHeight;\n  //     camera.updateProjectionMatrix();\n  //   }\n  //   texture.needsUpdate = true;\n  //   cubes.forEach((cube, ndx) => {\n  //     const speed = 0.2 + ndx * 0.1;\n  //     const rot = time * speed;\n  //     cube.rotation.x = rot;\n  //     cube.rotation.y = rot;\n  //   });\n  //   renderer.render(scene, camera);\n  //   requestAnimationFrame(render);\n  // }\n  // requestAnimationFrame(render);\n};\n_c = ThreeCanvas;\n\nvar _c;\n\n$RefreshReg$(_c, \"ThreeCanvas\");","map":{"version":3,"sources":["/Users/pflaxalt/Repositories/_pfl/web/sketches/three/with-canvas-as-texture.ts"],"names":["ThreeCanvas","container","CanvasTheme"],"mappings":"AAGA;AACA;AAOA,OAAO,IAAMA,WAAoC,GAAG,SAAvCA,WAAuC,CAClDC,SADkD,EAElDC,WAFkD,EAG/C,CACH;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACD,CA5EM;KAAMF,W","sourcesContent":["import * as THREE from \"three\";\nimport { LXLT_ColorTheme } from \"../../constants/styles/Color\";\n\n// Begin Component\n// __________________________________________________________________________\n\nexport type LXLT_ThreeCanvasDisplay = (\n  container: HTMLDivElement,\n  CanvasTheme: LXLT_ColorTheme\n) => void;\n\nexport const ThreeCanvas: LXLT_ThreeCanvasDisplay = (\n  container,\n  CanvasTheme\n) => {\n  // var renderer, scene, camera, sketch;\n\n  // const canvas: HTMLCanvasElement = document.getElementById(\n  //   \"defaultCanvas0\"\n  // ) as HTMLCanvasElement;\n\n  // renderer = new THREE.WebGLRenderer({ canvas });\n  // sketch = container;\n  // renderer.setPixelRatio(window.devicePixelRatio);\n  // renderer.setSize(window.innerWidth, window.innerHeight);\n  // sketch.appendChild(renderer.domElement);\n\n  // const fov = 75;\n  // const aspect = 2; // the canvas default\n  // const near = 0.1;\n  // const far = 5;\n  // camera = new THREE.PerspectiveCamera(fov, aspect, near, far);\n  // camera.position.z = 2;\n\n  // scene = new THREE.Scene();\n\n  // const boxWidth = 1;\n  // const boxHeight = 1;\n  // const boxDepth = 1;\n  // const geometry = new THREE.BoxGeometry(boxWidth, boxHeight, boxDepth);\n\n  // const cubes = []; // just an array we can use to rotate the cubes\n  // // @ts-ignore\n  // const texture = new THREE.CanvasTexture(canvas);\n\n  // const material = new THREE.MeshBasicMaterial({\n  //   map: texture,\n  // });\n  // const cube = new THREE.Mesh(geometry, material);\n  // scene.add(cube);\n  // cubes.push(cube); // add to our list of cubes to rotate\n\n  // function resizeRendererToDisplaySize(renderer) {\n  //   const canvas = renderer.domElement;\n  //   const width = canvas.clientWidth;\n  //   const height = canvas.clientHeight;\n  //   const needResize = canvas.width !== width || canvas.height !== height;\n  //   if (needResize) {\n  //     renderer.setSize(width, height, false);\n  //   }\n  //   return needResize;\n  // }\n\n  // function render(time) {\n  //   time *= 0.001;\n\n  //   if (resizeRendererToDisplaySize(renderer)) {\n  //     const canvas = renderer.domElement;\n  //     camera.aspect = canvas.clientWidth / canvas.clientHeight;\n  //     camera.updateProjectionMatrix();\n  //   }\n\n  //   texture.needsUpdate = true;\n\n  //   cubes.forEach((cube, ndx) => {\n  //     const speed = 0.2 + ndx * 0.1;\n  //     const rot = time * speed;\n  //     cube.rotation.x = rot;\n  //     cube.rotation.y = rot;\n  //   });\n\n  //   renderer.render(scene, camera);\n\n  //   requestAnimationFrame(render);\n  // }\n\n  // requestAnimationFrame(render);\n};\n"]},"metadata":{},"sourceType":"module"}