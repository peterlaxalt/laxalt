{"ast":null,"code":"import * as THREE from \"three\"; // import { GUI } from \"./jsm/libs/dat.gui.module.js\";\n\nimport { OrbitControls } from \"./jsm/controls/OrbitControls.js\";\nexport var canvas = function canvas(container) {\n  /**\n   * Setup\n   */\n  var mesh, renderer, scene, camera, controls, sketch;\n  var gui;\n  var API = {\n    offsetX: 0,\n    offsetY: 0,\n    repeatX: 0.25,\n    repeatY: 0.25,\n    rotation: Math.PI / 4,\n    // positive is counter-clockwise\n    centerX: 0.5,\n    centerY: 0.5\n  };\n  init();\n\n  function init() {\n    renderer = new THREE.WebGLRenderer();\n    sketch = container;\n    renderer.setPixelRatio(window.devicePixelRatio);\n    renderer.setSize(window.innerWidth, window.innerHeight);\n    sketch.appendChild(renderer.domElement);\n    scene = new THREE.Scene();\n    camera = new THREE.PerspectiveCamera(40, window.innerWidth / window.innerHeight, 1, 1000);\n    camera.position.set(0, 0, 25);\n    scene.background = new THREE.Color(0xffffff);\n    scene.add(camera);\n    /**\n     * Camera controls\n     */\n\n    controls = new OrbitControls(camera, renderer.domElement);\n    controls.movementSpeed = 10000;\n    controls.domElement = renderer.domElement;\n    controls.rollSpeed = Math.PI / 24;\n    controls.autoForward = true;\n    controls.dragToLook = true;\n    controls.enableZoom = false;\n    var geometry = new THREE.TorusKnotBufferGeometry(10, 3, 200, 200);\n    new THREE.TextureLoader().load(\"/projects/three/19of19-tile-white.png\", function (texture) {\n      texture.wrapS = texture.wrapT = THREE.RepeatWrapping; // texture.anisotropy = renderer.capabilities.getMaxAnisotropy();\n\n      texture.anisotropy = 1; //texture.matrixAutoUpdate = false; // default true; set to false to update texture.matrix manually\n\n      var material = new THREE.MeshBasicMaterial({\n        map: texture\n      });\n      mesh = new THREE.Mesh(geometry, material);\n      scene.add(mesh);\n      updateUvTransform();\n      animate();\n    });\n    window.addEventListener(\"resize\", onWindowResize, false);\n  } // our scale of the pattern\n\n\n  var repeatX = 0;\n  var repeatY = 0;\n  var frameCount = 0;\n\n  function animate() {\n    // call animate recursively\n    requestAnimationFrame(animate); // texture manipulation\n\n    var texture = mesh.material.map;\n    frameCount += 1;\n    repeatX += 0.01;\n    repeatY += 0.01; // if (repeatX < 13) {\n    //   repeatX += 0.01;\n    //   repeatY += 0.01;\n    // } else {\n    //   repeatX += 0.001;\n    //   repeatY += 0.001;\n    // }\n    // else {\n    //   if (repeatY < 60) {\n    //     repeatY += 0.05;\n    //   } else {\n    //     repeatX += 0.05;\n    //   }\n    // }\n    // console.log(\n    //   \"repeatX: \" +\n    //     repeatX +\n    //     \", repeatY: \" +\n    //     repeatY +\n    //     \", frameCount: \" +\n    //     frameCount\n    // );\n    // console.log(texture);\n\n    texture.rotation += 0.0001;\n    texture.repeat = {\n      x: repeatX,\n      y: repeatY\n    }; // increase the mesh's rotation each frame\n\n    mesh.rotation.z += 0.0008;\n    mesh.rotation.x += 0.0008;\n    mesh.rotation.y += 0.0008; // render, or 'create a still image', of the scene\n    // this will create one still image / frame each time the animate\n    // function calls itself\n\n    renderer.render(scene, camera);\n  }\n\n  function render() {\n    renderer.render(scene, camera);\n  }\n\n  function onWindowResize() {\n    camera.aspect = window.innerWidth / window.innerHeight;\n    camera.updateProjectionMatrix();\n    renderer.setSize(window.innerWidth, window.innerHeight);\n    render();\n  }\n\n  function updateUvTransform() {\n    var texture = mesh.material.map;\n\n    if (texture.matrixAutoUpdate === true) {\n      texture.offset.set(API.offsetX, API.offsetY); // texture.repeat.set(API.repeatX, API.repeatY);\n\n      texture.center.set(API.centerX, API.centerY); // texture.rotation = API.rotation; // rotation is around [ 0.5, 0.5 ]\n    } else {\n      // one way...\n      //texture.matrix.setUvTransform( API.offsetX, API.offsetY, API.repeatX, API.repeatY, API.rotation, API.centerX, API.centerY );\n      // another way...\n      texture.matrix.identity().translate(-API.centerX, -API.centerY) // .rotate(API.rotation) // I don't understand how rotation can preceed scale, but it seems to be required...\n      // .scale(API.repeatX, API.repeatY)\n      .translate(API.centerX, API.centerY).translate(API.offsetX, API.offsetY);\n    }\n\n    render();\n  } // function initGui() {\n  //   gui = new GUI();\n  //   gui\n  //     .add(API, \"offsetX\", 0.0, 1.0)\n  //     .name(\"offset.x\")\n  //     .onChange(updateUvTransform);\n  //   gui\n  //     .add(API, \"offsetY\", 0.0, 1.0)\n  //     .name(\"offset.y\")\n  //     .onChange(updateUvTransform);\n  //   // gui\n  //   //   .add(API, \"repeatX\", 0.25, 2.0)\n  //   //   .name(\"repeat.x\")\n  //   //   .onChange(updateUvTransform);\n  //   // gui\n  //   //   .add(API, \"repeatY\", 0.25, 2.0)\n  //   //   .name(\"repeat.y\")\n  //   //   .onChange(updateUvTransform);\n  //   // gui\n  //   //   .add(API, \"rotation\", -2.0, 2.0)\n  //   //   .name(\"rotation\")\n  //   //   .onChange(updateUvTransform);\n  //   gui\n  //     .add(API, \"centerX\", 0.0, 1.0)\n  //     .name(\"center.x\")\n  //     .onChange(updateUvTransform);\n  //   gui\n  //     .add(API, \"centerY\", 0.0, 1.0)\n  //     .name(\"center.y\")\n  //     .onChange(updateUvTransform);\n  // }\n\n}; // export const canvas = container => {\n//   // these need to be accessed inside more than one function so we'll declare them first\n//   let camera;\n//   let renderer;\n//   let scene;\n//   let mesh;\n//   function init() {\n//     // create a Scene\n//     scene = new THREE.Scene();\n//     scene.background = new THREE.Color(0x8fbcd4);\n//     // set up the options for a perspective camera\n//     const fov = 35; // fov = Field Of View\n//     const aspect = container.clientWidth / container.clientHeight;\n//     const near = 0.1;\n//     const far = 100;\n//     camera = new THREE.PerspectiveCamera(fov, aspect, near, far);\n//     // every object is initially created at ( 0, 0, 0 )\n//     // we'll move the camera back a bit so that we can view the scene\n//     camera.position.set(0, 0, 10);\n//     // create a geometry\n//     const geometry = new THREE.BoxBufferGeometry(2, 2, 2);\n//     // create a purple Standard material\n//     const material = new THREE.MeshStandardMaterial({ color: 0x800080 });\n//     // create a Mesh containing the geometry and material\n//     mesh = new THREE.Mesh(geometry, material);\n//     // add the mesh to the scene object\n//     scene.add(mesh);\n//     // Create a directional light\n//     const light = new THREE.DirectionalLight(0xffffff, 5.0);\n//     // move the light back and up a bit\n//     light.position.set(10, 10, 10);\n//     // remember to add the light to the scene\n//     scene.add(light);\n//     // create a WebGLRenderer and set its width and height\n//     renderer = new THREE.WebGLRenderer({ antialias: true });\n//     renderer.setSize(container.clientWidth, container.clientHeight);\n//     renderer.setPixelRatio(window.devicePixelRatio);\n//     // add the automatically created <canvas> element to the page\n//     container.appendChild(renderer.domElement);\n//   }\n//   function animate() {\n//     // call animate recursively\n//     requestAnimationFrame(animate);\n//     // increase the mesh's rotation each frame\n//     mesh.rotation.z += 0.01;\n//     mesh.rotation.x += 0.01;\n//     mesh.rotation.y += 0.01;\n//     // render, or 'create a still image', of the scene\n//     // this will create one still image / frame each time the animate\n//     // function calls itself\n//     renderer.render(scene, camera);\n//   }\n//   // call the init function to set everything up\n//   init();\n//   // then call the animate function to render the scene\n//   animate();\n// };","map":null,"metadata":{},"sourceType":"module"}